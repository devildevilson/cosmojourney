#ifndef COSMOJOURNEY_SOUND_REESOURCE_H
#define COSMOJOURNEY_SOUND_REESOURCE_H

#include <cstddef>
#include <cstdint>
#include <memory>
#include <functional>
#include <demiurg/resource_base.h>
#include <sound/system.h>
using namespace devils_engine;

namespace cosmojourney {
  class sound_resource;

  namespace sound_actions_detail {
#define X(name) void name(sound_resource* res, const utils::safe_handle_t &handle);
  DEMIURG_ACTIONS_LIST
#undef X
  }  // namespace sound_actions_detail

  // толку с этого особенно никакого нет
  // я думал что получиться определить таблицу в cpp файле
  // но так не сработало, для чего я в принципе делал эти вещи?
  // хотел чтобы у каждого ресурса была своя стейтмашина и можно было легко понять что к чему
  // 
  struct sound_resource_table {
      auto operator()() const {
//#define X(name) const std::function<void(sound_resource* res, void* ptr)> name = &sound_actions_detail::name;
//        DEMIURG_ACTIONS_LIST
//#undef X

#define X(name) const auto l##name = [](demiurg::inj<sound_resource> i, const auto& event){ sound_actions_detail::name(i.ptr, event.handle); };
        DEMIURG_ACTIONS_LIST
#undef X

      using namespace sml;
      return make_transition_table(
        *state<demiurg::unload> + event<demiurg::loading> / lload_to_memory = state<demiurg::memory_load>,
         state<demiurg::memory_load> + event<demiurg::unloading> / lunload = state<demiurg::unload>
      );
    }
  };

  class sound_resource final : public demiurg::resource_base<sound_resource_table> {
  public:
    sound_resource() noexcept;
    ~sound_resource() noexcept = default;

    void unload(const utils::safe_handle_t& handle) override;
    void load_to_memory(const utils::safe_handle_t& handle) override;

    // как то нужно собственно сам ресурс передавать из места к месту
    // но хотя это все равно будет через тот или иной прокси
    // где мы собственно преобразуем ресурс к необходимому виду
    // например при передаче ресурса в звук, мы сначала поймем что перед нами
    // преобразуем и запустим нужную функцию
    // в конфигах наверное мы будем через require получать объект с ресурсом
    // нам может пригодиться для интерфейса вся информация о ресурсе
    // в том числе также мы сделаем подгрузку скриптов
  private:
    std::unique_ptr<sound::system::resource> res;
  };
}

// возвращаясь к разговору о ресурсах: ресурсы вообще говоря могут находиться только в 3х состояниях
// холодные, теплые и горячие (на диске, в памяти, полностью загруженные)
// например: музыку заднего фона необязательно держать постоянно в памяти, поэтому мы можем ее выгружать
// после воспроизведения; текстурку мы можем держать на диске пока не потребуется (холодная), 
// загрузить в стейджинг буфер (теплая), скопировать на ГПУ (горячая)
// все преобразования текстурок конечно лучше заранее сделать (то есть сжатие BC7 например)
// тогда загрузка не будет длиться вечность, нам останется только скопировать текстурку из памяти
// условно говря нам нужно 4 функций: холодная -> теплая, теплая -> горячая, горячая -> теплая, теплая -> холодная
// некоторые ресурсы имеет смысл сразу полностью загружать и сразу полностью выгружать за ненадобностью
// например иконки - вроде и картинка а вряд ли у нас будут иконки которые нужно подгружать как то в рантайме
// все иконки скорее всего сразу будут сидеть в текстурном массиве... да таким образом
// у меня вот что еще получается: есть текстурки которые сидят в текстурном массиве, 
// есть текстурки которые сидят в спарс памяти, есть текстурки которые сидят отдельно
// это 3 разные системы хранения: например для задника для загрузки можно создать одну большую текстурку 
// и в нее пересовывать картинку просто
// для иконок и сопроводительных картинок - создадим текстурный массив
// для всех остальных текстурок (основных игровых) сделаем спарс память
// для хорошо структурированных текстурок поди тоже можно использовать текстурный массив
// например если у нас какая то тайловая графика, да скорее всего все тайлы
// пойдут в массив, а условный задний фон пойдет в спарс...
// нет в спарс как будто только может пойти текстурка которая больше определнного размера и используется например
// в отрисовке террейна и все, остальные вещи не подходят по идее
// что мы можем сделать иначе? изначально определить некий бюджет видеопамяти
// например условно мы хотим использовать не больше 256мб памяти
// в нем определить сколько всего у нас будет текстурок какого размера, 
// например тут будет 8 текстурок 1к, 16 512, 32 256 и далее
// для игровой текстурки возможно будут загружены два мип уровня одновременно
// (нет, возможно и больше) в зависимости от окружения, в принципе мы можем пользоваться мип уровнаями выше или ниже
// может быть использовать байндлесс текстуры... байндлесс текстурные массивы
// 128мб памяти делим между 32 участками памяти на одну из которых помещаем либо
// 1 1024 текстурку, 16 512 текстурок, 64 256 текстурок, 256 128 текстурок
// у 1к текстурки есть мип уровни, которые просто копируем в незанятый слот
// используем мипуровки как отдельные картинки
// как правильно понять какие слоты занимать, какие освобождать и далее?
// если не выпендриваться и сделать константное количество текстурок определенного качества
// то тогда все довольно понятно становится 
// для чего мне может потребоваться 16 текстурок 1024 одновременно? наивысшее качество?
// это близкие предметы на который основной фокус: персонажи и противники
// например НПС в геншине используют 1024... даже несколько 1024 текстурок
// диффуз (1024), карта света (1024) + шедов (256х20)

#endif
#ifndef DEVILS_ENGINE_PAINTER_SYSTEM_H
#define DEVILS_ENGINE_PAINTER_SYSTEM_H

#include <cstddef>
#include <cstdint>
#include "vulkan_minimal.h"

// в системе нужно еще задать кеши, например пиплайн и скомпилированный шейдер кеш
// + добавить флаги чтобы не использовать кеши

// да еще в вулкане какая то тупая система чтобы найти нужный физикал девайс
// проще как то заранее отыскать с минимальным стейтом, потом передать (что?) в основную систему
// все пересоздав с нуля

// как дела обстоят с шейдерами? есть ресурс который смотрит на текстовый файл на диске
// этому ресурсу необходимо получить define'ы определить их в компиляторе и выдать скомпилированный вид
// какие дефайны? это пачка определений буферов + возможно что то от пользователя
// затем это передается в создание пайплайна, где желательно понять из самого шейдера
// какие данные требуются на вход при создании пайпа + константы, которые тоже задаем от пользователя
// обработка include
// https://stackoverflow.com/questions/67393985/shaderc-includerinterface-include-fails
// у glsl есть еще какая то рефлексия насколько она мне понадобится?
// не уверен, скорее всего я сгенерирую структуры заранее положу их файлом на диск
// в этом файле наверное будет перечисление вроде:
// #ifdef DEVILS_ENGINE_SHADER_VERTEX_INPUT_DEFINITION_TEST1
// location(binding = 0) struct gpu_tiles { vec4 data; };
// #endif
// и при компиляции нужно будет указать название директивы и биндинг? похоже на то
// + свяжем это дело с инпутом в пиплайне и с биндингами в командном буфере
// дополнительно будут еще юниформ буферы и сторадж буферы
// вот их без проблем можно сразу закинуть через дескрипторы
// + нужно указать выходные буферы и данные
// хотя выходные буферы собственно тоже будут заданы через дескрипторы
// что делать с выходом из фрагментного шейдера? он чисто зависит от текущего рендерпасса
// когда мы объявляем вообще весь пайп в файлике, там как раз укажем какие данные мы берем откуда
// осталось понять как добавить текстурные данные только для чтения
// + нам бы еще сделать кеш скомпилированных шейдеров

// создал почти все мне необходимое, что теперь?
// эту структуру в пору переназвать как нибудь, можно просто контейнер
// она нам нужно чтобы с ее поощью создавать оставшиеся рендер штуки
// тут наверное будем еще хранить кеш шейдеров в каком нибудь виде
// где создадим сюрфейс и свопчеин? вообще так то можно и тут
// нет свопчаин сильно зависит от рендертаргета (ну то есть это он и есть)
namespace devils_engine {
namespace painter {
struct system {
  VkInstance instance;
  VkDebugUtilsMessengerEXT debug_messenger;
  VkPhysicalDevice physical_device;
  VkDevice device;
  VkQueue graphics_queue;
  VkQueue compute_queue;
  VkQueue presentation_queue;
  VkPipelineCache cache;

  VmaAllocator buffer_allocator;
  VkDescriptorPool descriptor_pool;

  VkCommandPool graphics_command_pool;
  VkCommandPool transfer_command_pool;
  VkFence transfer_fence;

  VkSurfaceKHR surface;
  VkSwapchainKHR swapchain;

  system();
  ~system() noexcept;

  void flush_cache();
};
}
}

#endif